import java.util.Random; // Importing random utility for AI opponent

class ConnectFour {
  
  // Char array for the game board (6x7 board)
  // Made public so that any method can access it, without passing it
  // Needs to be modified a lot, public array makes it easy to have it changed that often
  public static char[][] board = new char[6][7];
  
  public static void main (String [] args) {
    //int user1, user2; // Int vars for the user inputs
    char player1 = 82, player2 = 89; // Char variables for the players' chips
    int playerTurn; // Int var that makes each player take turns, set at zero for first players turn
    boolean gameOver, replayGame, exitGame = false; // Boolean variable to determine whether or not the game is over, and for whether or not to end the program
    int choice, cpuMove; // Int for the choice of the user and for the move of the computer
    System.out.println("Welcome to Connect Four!"); // Initial statement  
    do {
      choice = mainMenu(); // choice of the user will be the return value of the mainMenu function
      
      // If user selects option 1 (play connect 4), enters gamemode select 
      if (choice == 1) {
        
        
        // If user chooses choice 1, runs Person v person gamemode
        if (chooseMode() == 1) {
          do { // Loop through game 
            setupBoard(); // Calling setupBoard method to set up the board for a new game
            printBoard(board); // Calling print board method to print the board, before the loop
            playerTurn = 0; // Setting the playerTurn var to 0 to make player 1 start
            
            do { // Do loop to cycle through each players' turn
              
              if (playerTurn%2 == 0) { // If playerTurn mod 2 is zero, player 1 has their turn
                boardInteraction(player1, userInput(1)); // Call for boardInteraction method to set player 1's piece on the board 
              }
              else { // If the remainder is not 0, player 2 has their turn 
                boardInteraction(player2, userInput(2)); // Call for boardInteraction method to set player 2's piece on the board
              }
              
              printBoard(board); // Calling print board method to print the board
              
              if (playerTurn%2 == 0) {
                if (winChecker(player1) == true) { // If the win checker returns true, says player 1 wins, sets gameOver to true to end the loop
                  System.out.println("Player 1 wins!");
                  gameOver = true;
                }
                else { // If not, sets gameOver to false, continuing the game
                  gameOver = false;
                }
              }
              else {
                if (winChecker(player2) == true) { // If the win checker returns true, says player 2 wins, sets gameOver to true to end the loop
                  System.out.println("Player 2 wins!");
                  gameOver = true;
                }
                else { // If not, sets gameOver to false, continuing the game
                  gameOver = false;
                }
              }
              
              // Checking for tie game
              if (gameOver == false) { // If the game still hasn't ended yet (no one has won), will then continue to check if it's a tie game
                if (tieChecker() == true) { // If tieCheker returns true, sets gameOver to true and says game ends in tie
                  gameOver = true;
                  System.out.println("Game has ended in a tie.");
                }
                else { // If tieChecker returns false, keeps game going
                  gameOver = false;
                }
              }
              
              playerTurn++; // Adding one to playerTurn int to make sure the next loop changes turns 
            } while (gameOver == false); // Game ends when gameOver boolean becomes true
            
            replayGame = replayGame(); // replayGame will be the return value of the replayGame method
          } while (replayGame == true); // Program ends when replayGame is equal to false
        }
        
        
        // If user chooses choice 2, enters AI versus mode
        else {
          do { // Loop through game
            System.out.println("\nAI versus mode");
            setupBoard(); // Calling setupBoard method to set up the board for a new game
            printBoard(board); // Calling print board method to print the board, before the loop
            playerTurn = 0; // Setting the playerTurn var to 0 to make player 1 start
            
            do { // Do loop to cycle through each players' turn
              
              if (playerTurn%2 == 0) { // If playerTurn mod 2 is zero, player 1 has their turn
                boardInteraction(player1, userInput(1)); // Call for boardInteraction method to set player 1's piece on the board 
              }
              else { // If the remainder is not 0, computer has their turn
                cpuMove = computerMove(player1, player2); // CPU move will be the return value of computerMove
                System.out.print("Computer's move : " + (cpuMove + 1) + "\n"); // Displays move of computer1
                
                boardInteraction(player2, cpuMove); // Call for boardInteraction method to set player 2's piece on the board
              }
              
              printBoard(board); // Calling print board method to print the board
              
              if (playerTurn%2 == 0) {
                if (winChecker(player1) == true) { // If the win checker returns true, says player 1 wins, sets gameOver to true to end the loop
                  System.out.println("Player wins!");
                  gameOver = true;
                }
                else { // If not, sets gameOver to false, continuing the game
                  gameOver = false;
                }
              }
              else {
                if (winChecker(player2) == true) { // If the win checker returns true, says player 2 wins, sets gameOver to true to end the loop
                  System.out.println("Computer wins!");
                  gameOver = true;
                }
                else { // If not, sets gameOver to false, continuing the game
                  gameOver = false;
                }
              }
              
              // Checking for tie game
              if (gameOver == false) { // If the game still hasn't ended yet (no one has won), will then continue to check if it's a tie game
                if (tieChecker() == true) { // If tieCheker returns true, sets gameOver to true and says game ends in tie
                  gameOver = true;
                  System.out.println("Game has ended in a tie.");
                }
                else { // If tieChecker returns false, keeps game going
                  gameOver = false;
                }
              }
              
              playerTurn++; // Adding one to playerTurn int to make sure the next loop changes turns 
            } while (gameOver == false); // Game ends when gameOver boolean becomes true
            
            replayGame = replayGame(); // replayGame will be the return value of the replayGame method
          } while (replayGame == true); // Program ends when replayGame is equal to false
        }
      }
      // If user chooses the 2nd option, runs rules method
      else if (choice == 2) {
        rules(); // Calling rules method to print the rules
      }
      // If user chooses the 3rd option
      else if (choice == 3){
        System.out.println("\nMade by Nabeel Warsalee\nICS3U Final Project\nJune 5th, 2017"); // Credits statement
      }
      else {
        exitGame = exitGame(); // exitGame boolean will be the return value of the exitGame method
      }
      System.out.println(""); // Printing blank line
    } while (exitGame == false);
    System.out.println("Thanks for playing!!!\n\nMade by Nabeel Warsalee\nICS3U Final Project\nJune 5th, 2017");
  }
  
  
  // Void method to print the game board
  public static void printBoard (char[][] board) {
    System.out.println("        Board       "); // Line that says it's the board
    System.out.println(" 1  2  3  4  5  6  7"); // Prints numbers over the columns
    for (int y=0; y<6; y++) { // Cycles through the rows
      for (int x=0; x<7; x++) { // Cycles through the columns
        System.out.print("[");
        System.out.print(board[y][x]); // Prints the value of board array at index y,x
        System.out.print("]");
      }
      System.out.print("\n");
    }
  }
  
  // Void method to print the list of rules for the game
  public static void rules () {
    System.out.println("\nThese are the rules...");
    System.out.println("- Be the first player to get four of your chips in a horizontal, vertical or diagonal line.");
    System.out.println("- Choose a column on the board to drop your chip.");
    System.out.println("- Each player takes turns placing their chips on the board.");
    System.out.println("- Player 1 (Red) always starts first.");
  }
  
  // Return method for the users input
  public static int userInput (int player) { 
    int userIn = 0; // Int for the user input (preset to 0 to be able to compile)
    String input; // String for the users input
    boolean validInput = true; // Boolean for wether or not it's a valid input, boolean for whether or not a column is full
    
    // Prompt for user input
    do {
      
      try {
        // Getting user's input
        System.out.print("Player " + player + " turn : ");
        input = In.getString();
        
        // Attempting to parse the users input that is a string into an int
        // If it can't parse the string into an int, errors and goes to the catch statement
        userIn = Integer.parseInt(input);
        
        if (!(userIn >= 1 && userIn <=7)) { // If the user input is not between 1 and 7, sets validInput to false
          validInput = false;
          System.out.println("Not a valid input. Enter a value between 1 and 7.");
        }
        // If the column that the user's trying to place their chip is full (Looks at the top position to check if the column's full]), asks them to re-enter
        else if (board[0][userIn-1] != 32) {
          validInput = false;
          System.out.println("Selected column is full.");
        }
        else {
          validInput = true;
        }
      }
      catch (Exception e) { // catches any exception
        System.out.println("Not a valid input.");
        validInput = false;
      }
    } while (validInput == false); // Loop exits when the user input is a valid one
    return userIn -=1; // Takes their value and substracts 1 (to avoid array out of bounds error), returns it
  }
  
  // Void method to set the player's pieces on the game board
  public static void boardInteraction (char playerChip, int move) {
    boolean chipPlaced; // Boolean variable for whether or not a chip has already placed
    //int userIn = userInput(player); // Getting the users input
    for (int i=0; i<7; i++) { // Looping through the columns
      chipPlaced = false; // Sets chipPlaced to false meaning that a chip must be placed
      if (move == i) { // When it reaches the column that the player desires
        for (int x=5; x>=0; x--) { // Loops through the rows, (From bottom of the board to the top)
          if (board[x][i] == 32 && chipPlaced == false) {
            board[x][i] = playerChip; // Changes the value of the element at index x, i to the char 'R'
            chipPlaced = true; // Sets chipPlaced to true, meaning a chip was placed and a second chip should not be plavced this turn
          }
        }
      }
    }
  }
  
  // Return method to return whether or not someone has one the game
  public static boolean winChecker (char playerChip) {
    boolean winner = false; // Boolean var for if there's a winner
    // Series of for loops and selection statements to determine if someone has won in the horizontal direction.
    for (int i=0; i<7; i++) { // Cycling through the columns
      for (int x=5; x>=0; x--) { // Cycling through the rows
        if (board[x][i] == playerChip && winner == false) { // If that certain position on the board is equal to the playerChip char
          
          // Try and catch statments around each directional checker to avoid array out of bounds errors
          
          //Horizontal direction
          try {
            if (board[x][i+1] == playerChip && winner == false) {
              if (board[x][i+1] == playerChip && board[x][i+2] == playerChip && board[x][i+3] == playerChip) { // If the 3 proceeding chars in the horizontal direction are the same value, sets winner to true
                winner = true;
              }
              else {
                winner = false;
              }
            }
          }
          catch (Exception e) {
          }
          
          // Vertical direction
          try {
            if (board[x-1][i] == playerChip && winner == false) {
              if (board[x-1][i] == playerChip && board[x-2][i] == playerChip && board[x-3][i] == playerChip){ // If the 3 proceeding chars in the vertical direction are the same value, sets winner to true
                winner = true;
              }
              else {
                winner = false;
              }
            }
          }
          catch (Exception e) {
          }
          
          // Diagonal directions (From lower left to upper right direction)
          try {
            if (board[x-1][i+1] == playerChip && winner == false) {
              if (board[x-1][i+1] == playerChip && board[x-2][i+2] == playerChip && board[x-3][i+3] == playerChip) { // If the 3 proceeding chars in the diagonal direction are the same value, sets winner to true
                winner = true;
              }
              else {
                winner = false;
              }
            }
          }
          catch (Exception e) {
          }
          
          // Diagonal directions (From lower right to upper left direction)
          try {
            if (board[x-1][i-1] == playerChip && winner == false) {
              if (board[x-1][i-1] == playerChip && board[x-2][i-2] == playerChip && board[x-3][i-3] == playerChip) { // If the 3 proceeding chars in the vertical direction are the same value, sets winner to true
                winner = true;
              }
              else {
                winner = false;
              }
            }
          }
          catch (Exception e) {
          }
          
        }
      }
    }
    return winner; 
  }
  
  // Return method to indicate whether or not it's a tie game (seen by the whole board being filled without a line of 4)
  // Should be used after the winChecker method to ensure that noyone has won
  public static boolean tieChecker () {
    boolean tieGame = false; // Variable for if their is a tie game
    boolean tieSeen = true; // Variable to indicate whether or not a tie game was witnessed
    for (int i=0; i<6; i++) {
      for (int x=0; x<7; x++) {
        if (tieSeen == true) { // If it hasn't detected a tie, continues to loop
          if (board[i][x] == 32) {
            tieGame = false;
            tieSeen = false;
          }
          else {
            tieGame = true;
            //tieSeen = true; // Once it detects a tie, 
          }
        }
      }
    }
    return tieGame;
  }
  
  // Void method to set the board up with empty spaces (used at the beginning of each match)
  public static void setupBoard () {
    // Setting all values of the board array to space char
    for (int y=0; y<6; y++) {
      for (int x=0; x<7; x++) {
        board[y][x] = 32;
      }
    }
  }
  
  // Return method to return whether or not the user wants to replay the game 
  public static boolean replayGame () {
    String userIn;
    boolean validInput, replayGame = true;
    
    System.out.println("\nDo you want to play again?\n(Type 'yes' to coninue, 'no' to return to main menu.)");
    do {
      userIn = In.getString();
      if (userIn.trim().toUpperCase().equals("YES")) { // If user types yes, sets replayGame to true, and validInput to true to exit loop
        replayGame = true;
        validInput = true;
      }
      else if (userIn.trim().toUpperCase().equals("NO")) { // If user types no, sets replayGame to false, and validInput to true to exit loop
        replayGame = false;
        validInput = true;
      }
      else { // If the input is anything else, sets validInput to false to loop again
        validInput = false;
        System.out.println("Invalid input.");
      }
    } while (validInput == false); // Continues loop while the input isn't valid
    
    return replayGame;
  }
  
  // Return method to return the choice that the user makes pertaining to gamemode
  public static int chooseMode () {
    String input;
    int userChoice = 0;
    boolean validInput = false;
    
    // Prompt for user input
    do {
      
      try {
        // Getting user's input
        System.out.println("\nWhich gamemode would you like to play?\n1) Person v.s Person\n2) Person v.s Computer");
        System.out.print("Choice : ");
        input = In.getString();
        
        // Attempting to parse the users input that is a string into an int
        // If it can't parse the string into an int, errors and goes to the catch statement
        userChoice = Integer.parseInt(input);
        
        if (!(userChoice >= 1 && userChoice <=2)) { // If the user input is not between 1 and 2, sets validInput to false
          validInput = false;
          System.out.println("Not a valid input.");
        }
        else {
          validInput = true;
        }
      }
      catch (Exception e) { // catches any exception
        System.out.println("Not a valid input.");
        validInput = false;
      }
    } while (validInput == false); // Loop exits when the user input is a valid one
    return userChoice;
  }
  
  // Return method to return the choice that the user makes at the main menu
  public static int mainMenu () {
    String input;
    int userChoice = 0;
    boolean validInput = false;
    
    // Prompt for user input
    do {
      
      try {
        // Getting user's input
        System.out.println("Main menu\n1) Play Connect Four\n2) How to play\n3) Credits\n4) Exit game");
        System.out.print("Choice : ");
        input = In.getString().trim();;
        
        // Attempting to parse the users input that is a string into an int
        // If it can't parse the string into an int, errors and goes to the catch statement
        userChoice = Integer.parseInt(input);
        
        if (!(userChoice >= 1 && userChoice <=4)) { // If the user input is not between 1 and 2, sets validInput to false
          validInput = false;
          System.out.println("Not a valid input.");
        }
        else {
          validInput = true;
        }
      }
      catch (Exception e) { // catches any exception
        System.out.println("Not a valid input.");
        validInput = false;
      }
    } while (validInput == false); // Loop exits when the user input is a valid one
    return userChoice;
  }
  
  // Return method to return whether or not the user wants to exit the program (clone of replayGame method)
  public static boolean exitGame () {
    String userIn;
    boolean validInput, exitGame = true;
    
    System.out.println("\nAre you sure you want to exit the program?\n(Type 'yes' to exit, 'no' to return to main menu.)");
    do {
      userIn = In.getString();
      if (userIn.trim().toUpperCase().equals("YES")) { // If user types yes, sets replayGame to true, and validInput to true to exit loop
        exitGame = true;
        validInput = true;
      }
      else if (userIn.trim().toUpperCase().equals("NO")) { // If user types no, sets replayGame to false, and validInput to true to exit loop
        exitGame = false;
        validInput = true;
      }
      else { // If the input is anything else, sets validInput to false to loop again
        validInput = false;
        System.out.println("Invalid input.");
      }
    } while (validInput == false); // Continues loop while the input isn't valid
    
    return exitGame;
  }
  
  // Return method to return the value of the computer's move
  public static int computerMove (char playerChar, char cpuChar) {
    Random rand = new Random(); // Creating random variable to get random number
    int move = 1; // Int for the comps move
    boolean validMove = false, moveChosen=false; // Boolean for whether or not the computer's move is valid or not and for whether or not it needs to defend
    
    // Checks to see if it needs to defend
    if (moveChosen == false) {
      for (int i=5; i>=0; i--) {
        for (int x=0; x<7; x++) {
          // Try statement to catch any array out of bounds errors
          try {
            // Trying to block horizontal moves to the right
            if (board[i][x] == playerChar && board[i][x+1] == playerChar && board[i][x+2] == playerChar && moveChosen == false) {
              if (x+3 <= 7 && board[i][x+3] == 32) {
                moveChosen = true;
                move = x+3;
              }
            }
          }
          catch (Exception e) {
          }
          try {
            // Trying to block horizontal moves to the left
            if (board[i][x] == playerChar && board[i][x-1] == playerChar && board[i][x-2] == playerChar && moveChosen == false) {
              if (x-3 >= 1 && board[i][x-3] == 32) {
                moveChosen = true;
                move = x-3;
              }
            }
          }
          catch (Exception e) {
          }
          try {
            // Trying to block vertical moves
            if (board[i][x] == playerChar && board[i-1][x] == playerChar && board[i-2][x] == playerChar && moveChosen == false) {
              if (board[0][x] == 32 && board[i-3][x] == 32) {
                moveChosen = true;
                move = x;
              }
            }
          }
          catch (Exception e) {
          }
        }
      }
    }
    
    // Checks to see if it needs to attack
    if (moveChosen == false) {
      for (int i=5; i>=0; i--) {
        for (int x=0; x<7; x++) {
          // Try statement to catch any array out of bounds errors
          try {
            // Trying to attack horizontal moves to the right
            if (board[i][x] == cpuChar && board[i][x+1] == cpuChar && board[i][x+2] == cpuChar && moveChosen == false) {
              if (x+3 <= 7 && board[i][x+3] == 32) {
                moveChosen = true;
                move = x+3;
              }
            }
          }
          catch (Exception e) {
          }
          try {
            // Trying to attack horizontal moves to the left
            if (board[i][x] == cpuChar && board[i][x-1] == cpuChar && board[i][x-2] == cpuChar && moveChosen == false) {
              if (x-3 >= 1 && board[i][x-3] == 32) {
                moveChosen = true;
                move = x-3;
              }
            }
          }
          catch (Exception e) {
          }
          try {
            // Trying to attack vertical moves
            if (board[i][x] == cpuChar && board[i-1][x] == cpuChar && board[i-2][x] == cpuChar && moveChosen == false) {
              if (board[0][x] == 32 && board[i-3][x] == 32) {
                moveChosen = true;
                move = x;
              }
            }
          }
          catch (Exception e) {
          }
        }
      }
    }
    
    // If it doesn't need to defend or attack, places the piece at random
    if (moveChosen == false) {
      do {
        move = rand.nextInt(7); // Generating random number between 1 and 7
        if (board[0][move] != 32) { // If the column is full, sets validMove to false
          validMove = false;
        }
        else { // If it's valid, sets validMove to true
          validMove = true;
        }
      } while (validMove == false);
    }
    return move;
  }
  
}
